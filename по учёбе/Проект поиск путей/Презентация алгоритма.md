Вводится понятия:
1) невозможного пути
2) Доминирующий путь. $p_2$ доминирует над $p_2$, если $g_1^d \geq g_2^d$ и $r_q^d \geq r_2^d$.
3) Объединённый путь. Путь, соединённый из двух частичных путей, найденных двунаправленным поиском.

Основная идея. Поиск делится на две стадии:
1) Инициализация
2) Основной поиск

Используется двунаправленный $A^*$ поиск для нахождения пути от начального до конечного узла. Этот путь называется первоначальным решением, а $C_0^*$ - стоимость его прохода. (У каждого направления поиска есть приоритетные очереди, в которых хранятся).

(Это делается потому, что алгоритму необходимо знать границу по стоимости прохода и по ресурсам, чтобы потом отбрасывать стратегии выходящие за эту границу, об этом в первом пункте следующего слайда.
А также, чтобы ограничить количество узлов, по которым будет вестись поиск, об этом во втором пункте следующего слайда).

Главные моменты стадии инициализации:
1) Использование A* ограниченного по расстоянию с последовательной и допустимой эвристикой для отбора узлов внутри верхней границы $C_0^*$.
2) Эвристика более высокого качества. (Ещё на стадии инициализации подразумевается отбор узлов в два этапа: по стоимости перехода и по ресурсу).
3) Более информированный A*. (То есть поиск в одном направлении может использовать результаты поиска в другом направлении).
4) Лучшее первоначальное решение. (То есть на стадии инициализации стараемся уменьшить разрыв минимальной стоимостью возможного пути и верхней границей, она же первоначальное решение $C_0^*$. То есть во время расширения узла в каждом ограниченном поиске мы пытаемся найти лучшие начальные ограничения, создавая полные пути, используя информацию узла, полученную ранее в обратном поиске.)

Главные моменты стадии основного поиска:
1) Разделение бюджета поиска по направлениям в зависимости от плотности узлов у конечного и начального узлов (Если до конечного узла добираться дешевле, то поиску от конечного узла выделяем бюджет меньше, чем поиску от начального узла и наоборот).
2) Очереди с приоритетом. 
   (Мы храним основную информацию о каждой частичном пути в уникальной метке (f-value, g-value, r, u - последний узел траектории). 
   Приоритетные очереди обрабатывают метки на основе их f-значения. 
   Алгоритм пытается расширить наиболее перспективный частичный путь, выбирая направление, которое предлагает меньшее значение $f$.
   После, новые сгенерированные частичные пути вставляются в соответствующую очередь приоритетов, если они соответствуют критериям выполнимости.
   Наконец, поиск успешно завершается, когда из любой из приоритетных очередей извлекается частичный путь с f-vaue, большим, чем текущее лучшее решение $C^*$)
3) Эффективная проверка доминирования. 
   (Общий подход для проверки доминирования заключается в сравнении новых частичных путей со всеми предыдущими частичными путями во время расширения.
   В данном алгоритме, чтобы проверить частичный путь на доминирование, нам просто нужно сравнить его использование ресурсов с потреблением ресурсов последнего (в очереди, т.к. очередь строится по возрастанию f-value) расширенного частичного пути узла).
4) Эффективное объединение частичных путей. 
   (Cохраняем расширенные частичные пути к узлу $v$ по порядку, первая/последняя добавленная метка имеет минимальную/максимальную стоимость среди частичных путей.
   Следовательно, процедуре сопряжения разрешается завершаться досрочно, при успешном сопоставление, или когда создает путь, который не так хорош, как лучший известный путь решения (неудачное сопоставление ).
   Наш второй метод. Мы не пытаемся сохранять/сопоставлять частичные пути, для которых мы уверены, что не будет аналога в обратном направлении. (как на картинке))

Реализации алгоритмов.
https://bitbucket.org/s-ahmadi/biobj/src/master/
Карты
https://www.diag.uniroma1.it/challenge9/download.shtml




