## Темы. С разделения по уровням компетенций

**ООП**.
Знание трёх китов ООП (Инкапсуляция, Наследование, Полиморфизм).
SOLID.

**Наследование**.
Применение наследование в базовых сценариях. Решение проблемы ромбовидного наследование.
Знание как наследование работает под капотом (конструирование/уничтожение объекта, представление в памяти, вызов виртуальных методов). Множественное наследование. Умение построить правильное дерево наследования (правильное выделение интерфейсов, принцип подстановки Лисков, рациональное использование наследования).
Знание как виртуальное наследование работает под капотом.

**Типизация**.
POD, приведение типов, правила выведения типа auto.
Знание как работает RTTI, move-семантика, rvalue.

**ADL, namespace**.
Понимание области видимости.
[Полное понимание Argument-dependet lookup](https://en.cppreference.com/w/cpp/language/adl).

**ABI**.
-.
Понимание проблем с C++ ABI, их решение.

**STL**.
Знание базовых контейнеров (vector, list, set, map, unordered_map). Знание сложности для этих контейнеров. Итераторы.
Использование алгоритмов для STL контейнеров. Правильный выбор контейнеров. Оптимизация их использования. Типы итераторов.
Знание внутренней реализации контейнеров.


**Управление памятью**.
Знание malloc, calloc, free, new, delete, умных указателей.
Понимание структуры памяти С++, знание реализации умных указателей.
Умение оптимизировать по использованию памяти (выравнивание памяти). Кастомные аллокаторы.

**template**.
Написание простых шаблонов. Использование любых шаблонов.
Использование decltype, шаблонных лямбд, constexpr_if.
Использование SFINAE, enable_if, концептов.

**lambda function => ФП**.

**Undefined behavior**.
Знание, что это за зверь. Избегание его.
Понимание разницы между undefined behavior и implementation-defined.
Отладка UB.

**Обработка ошибок (исключения, возврат ошибки)**.
Знание механизма исключений. 
Стоимость использования исключений. Понимает как работают механизмы распространения ошибок в языке.
Понимает разницу между исключениями и кодами возврата функций.

**C++20/23**.

## Мои ответы
## ООП
##### Инкапсуляция
Скрытие параметров объекта и предоставление возможности взаимодействия с ними только через интерфейсы.
##### Наследование
Возможность одним объектам перенимать функциональность и параметры других объектов.
##### Полиморфизм 
Свойство объектов обладать одинаковым интерфейсом. Но действия выполняются как правило не одинаковые.
*Косвенное свойство*.Возможность взаимодействовать не с каждым объектом отдельно, а взаимодействовать с группой объектов, через абстрактный (или можно сказать материнский) объект, от которого эта группа наследуется. Как раз таки благодаря тому, что интерфейс взаимодействия у каждого из объектов этой группы одинаковый.
##### Абстракция
Выделение общих характеристик объектов в виде абстрактных классов или интерфейсов.
##### SOLID
**SOLID** — это аббревиатура, которая описывает пять ключевых принципов проектирования и организации объектно-ориентированного кода.

Эти принципы были сформулированы Робертом Мартином (также известным как Uncle Bob) и включают в себя следующие концепции:
1. **Принцип единственной ответственности (Single Responsibility)**. Каждый класс или модуль в программе должен иметь только одну причину для изменения. Это означает, что класс должен выполнять только одну работу.
2. **Принцип открытости/закрытости (Open-Closed)**. Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
3. **Принцип подстановки Барбары Лисков (Liskov Substitution)**. Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения корректности программы. Это возможность заменять материнские классы дочерними.
4. **Принцип разделения интерфейса (Interface Segregation)**. Пользователи не должны зависеть от интерфейсов, которые они не используют. Если интерфейс большой, то должен быть разбит на несколько меньших и более конкретных, чтобы пользователи могли использовать только те интерфейсы, которые им нужны.
5. **Принцип инверсии зависимостей (Dependency Inversion)**. Зависимости внутри системы должны строиться на основе абстракций, а не деталей. Это означает, что высокоуровневые модули не должны зависеть от низкоуровневых модулей, и они все должны зависеть от абстракций.
Цель использования принципов SOLID — упростить разработку, сделать её более гибкой и устойчивой к ошибкам.
##### DRY
DRY - don't repeat yourself. Принцип пропагандирует избегать реализацию схожего функционала.
##### KISS
**KISS** - keep it simple and stupid. Пропагандирует решение задачи способ как можно проще.
##### YAGNI
**YAGNI** - You aren't gonna need it. Пропагандирует отказ от использования от избыточной функциональности.
### Наследование
##### Ромбовидное наследование
**Ромбовидное наследование** — ситуация в объектно-ориентированных языках программирования с поддержкой множественного наследования, когда два класса B и C наследуют от A, а класс D наследует от обоих классов B и C.

При этой схеме наследования может возникнуть неоднозначность: если объект класса D вызывает метод, определённый в классе A (и этот метод не был переопределён в классе D), а классы B и C по-своему переопределили этот метод, то от какого класса его наследовать: B или C?

 Компилятор обрабатывает каждый путь наследования отдельно, в результате чего объект D будет на самом деле содержать два разных подобъекта A, и при использовании членов A потребуется указать путь наследования (B::A или C::A).
### Типизация
##### POD
**POD** (Plain Old Data) обозначает определенные типы данных, которые имеют простую структуру и поведение, аналогичное C.
**Определение POD**. Согласно стандарту C++, POD должен удовлетворять следующим условиям:
1) Публичные члены: Все члены данных должны быть доступны без ограничений доступа (т.е. public).
2) Недоступные специальные функции: POD-тип не должен иметь пользовательских конструктора, деструкторов или операторов присваивания.
3) Не содержит виртуальных функций: POD-тип не должен иметь виртуальных функций.
4) Структура данных: Компоненты POD-типов должны быть простыми типами данных, такими как целые числа, символы или другие POD-типы.

### Проблемы с ABI и их решение
ABI определяет, как программы представляются в бинарном виде и как объявляются имена.
Нежелание комитета нарушать ABI может привести к стагнации и потере интереса к стандартной библиотеке. Производительность — это тот ключевой фактор, который удерживает библиотеку на плаву.

Предложения по изменению ABI.
- Добавление новых имен в библиотеку может быть дорогостоящим и сложным в использовании
- 

### Undefined behavior
